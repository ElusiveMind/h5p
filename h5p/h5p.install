<?php

/**
 * @file
 *  h5p.install php file
 *  Install and upgrade instructions for the h5p Drupal module.
 */

/**
 * Implementation of hook_install().
 */
function h5p_install() {
  drupal_install_schema('h5p');
}

/**
 * Implementation of hook_uninstall().
 */
function h5p_uninstall() {
  drupal_uninstall_schema('h5p');
}

/**
 * Implementation of hook_schema().
 */
function h5p_schema() {
  $schema['h5p_library_index'] = array( // TODO: Table names are usally in plural form to best describe their content. Also calling a table index is asking for confusion and trouble in SQL. A many to many relation table should have a name that reflects the tables it join together, example: http://guides.rubyonrails.org/images/habtm.png
    'description' => 'Stores information about what h5p uses what libraries.',
    'fields' => array(
      'content_id' => array(
        'description' => 'Primary Key: The unique identifier for a node(vid by default).',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'library_id' => array(
        'description' => 'The id of a h5p library this content uses',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'preloaded' => array(
        'description' => '0 if this library is dynamic, 1 if this library is to be preloaded',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
      ),
    ),
    'primary key' => array('content_id', 'library_id'),
  );

  $schema['h5p_library'] = array( // TODO: h5p_libraries
    'description' => 'Stores information about what h5p uses what libraries.',
    'fields' => array(
      'library_id' => array( // TODO: Primary identifiers are usally named just id so you can use $library->id, if it isn't you do not know what the primary identifier of an object is without going through the database schema(it could be lid, libid, etc. you don't know).
        'description' => 'Primary Key: The id of the library.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'machine_name' => array(
        'description' => 'The libraries machine name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',  
      ),
      'title' => array(
        'description' => 'The human readable name of this library',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'major_version' => array(
        'description' => 'The version of this library',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'minor_version' => array(
        'description' => 'The minor version of this library',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'patch_version' => array(
        'description' => 'The patch version of this library',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'runnable' => array(
        'description' => 'Whether or not this library is executable.',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
      ),
      'embed_types' => array(
        'description' => 'The allowed embed types for this library as a comma separated list',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'preloaded_js' => array(
        'description' => 'The preloaded js for this library as a comma separated list',
        'type' => 'text',
      ),
      'preloaded_css' => array(
        'description' => 'The preloaded css for this library as a comma separated list',
        'type' => 'text',
      ),
      'semantics' => array(
        'description' => 'The semantics definition in json format',
        'type' => 'text',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('library_id'),
  );
  
  $schema['h5p_library_dependency_index'] = array(
    'description' => 'Stores information about library dependencies.',
    'fields' => array(
      'library_id' => array(
        'description' => 'Primary Key: The id of a h5p library.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'machine_name' => array(
        'description' => 'The libraries machine name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'major_version' => array(
        'description' => 'Major version of the library this library depends on.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'minor_version' => array(
        'description' => 'Minor version of the library this library depends on.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'dependency_type' => array(
        'description' => 'preloaded, dynamic, or editor',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('library_id', 'machine_name'),
  );
  
  $schema['h5p_node'] = array(
    'description' => 'Stores information about where the h5p content is stored.',
    'fields' => array(
      'content_id' => array(
        'description' => 'Primary Key: The unique identifier for this node(vid by default).',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'nid' => array(
        'description' => 'The {node}.nid of the h5p node.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'json_content' => array(
        'description' => 'The content in json format',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'embed_type' => array(
        'description' => 'The embed type for this content',
        'type' => 'varchar',
        'length' => 127,
        'not null' => TRUE,
        'default' => '',
      ),
      'main_library' => array(
        'description' => 'The library we first instanciate for this node',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('content_id'),
  );
  return $schema;
}

/**
 * Implementation of hook_requirements().
 */
function h5p_requirements($phase) {
  $requirements = array();

  if ($phase == 'runtime') {
    // TODO: Add check for zip library
    // File paths
    $h5p_path = file_create_path(file_directory_path() .'/'. variable_get('h5p_default_path', 'h5p'));
    $temp_path = $h5p_path . '/temp';
    if (!file_check_directory($h5p_path, FILE_CREATE_DIRECTORY)) {
      $requirements['h5p_dirs'] = array(
        'value' => t('Missing directory.'),
        'severity' => REQUIREMENT_ERROR,
        'description' => t("The h5p module's package directory %h5p_path is missing.", array('%h5p_path' => $h5p_path)),
      );
    }
    else if (!file_check_directory($temp_path, FILE_CREATE_DIRECTORY)) {
      $requirements['h5p_dirs'] = array(
        'value' => t('Missing temp directory.'),
        'severity' => REQUIREMENT_ERROR,
        'description' => t("The h5p module's temp directory %temp_dir is missing.", array('%temp_dir' => $temp_path)), // TODO: misleading variable name: %temp_dir - note that it isn't the directory it self, it's the _path_ to the directory.
      );
    }
    else {
      $requirements['h5p_dirs'] = array(
        'value' => t('Exists (%path).', array('%path' => $h5p_path)),
        'severity' => REQUIREMENT_OK,
      );
    }
    $requirements['h5p_dirs']['title'] = t('h5p module directories');
  }

  return $requirements;
}